{"version":3,"file":"dusty.min.js","sources":["src/curry.js","src/add.js","src/and.js","src/_internals/isObject.js","src/not.js","src/complement.js","src/isNil.js","src/contains.js","src/defaults.js","src/flatten.js","src/difference.js","src/div.js","src/type.js","src/ensureArray.js","src/every.js","src/filter.js","src/find.js","src/fuzzySearch.js","src/gcd.js","src/has.js","src/identical.js","src/includes.js","src/intersection.js","src/is.js","src/_internals/array-from-iterator.js","src/_internals/equal.js","src/_internals/function-name.js","src/lcm.js","src/map.js","src/nth.js","src/mul.js","src/omit.js","src/or.js","src/partition.js","src/pipe.js","src/pluck.js","src/prepend.js","src/prop.js","src/reduce.js","src/reject.js","src/removeAt.js","src/replaceAt.js","src/round.js","src/slice.js","src/some.js","src/sort.js","src/sub.js","src/trim.js","src/union.js","src/uniq.js","src/assign.js","src/capitalize.js","src/clone.js","src/compress.js","src/curryN.js","src/deepClone.js","src/empty.js","src/entries.js","src/first.js","src/identity.js","src/isEmpty.js","src/isEqual.js","src/juxt.js","src/last.js","src/length.js","src/max.js","src/mean.js","src/min.js","src/range.js","src/reverse.js","src/values.js","src/words.js"],"sourcesContent":["/**\r\n * @name curry\r\n * @since v0.1.0\r\n * @category Function\r\n * @sig (* -> a) -> (* -> a)\r\n * @description Create a curried function\r\n * @param  {Function} f The function we will be running\r\n * @param  {Any} args extra args to apply if needed\r\n * @return {Any} Returns based on the function sent in\r\n *\r\n * @example\r\n * const add = curry((a, b) => a + b);\r\n *\r\n * add(1)(2); // => 3\r\n * add(1, 2); // => 3\r\n */\r\nconst curry = (f, ...args) => {\r\n  if (f.length <= args.length) {\r\n    return f(...args);\r\n  }\r\n\r\n  return (...rest) => curry(f, ...args, ...rest);\r\n};\r\n\r\nexport default curry;\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name add\r\n * @since v2.0.0\r\n * @category Number\r\n * @sig Number -> Number -> Number\r\n * @description Adds the provided items together\r\n * @param {Number} a The first number to add\r\n * @param {Number} b The second number to add\r\n * @return {Number} The sum of the numbers\r\n *\r\n * @example\r\n * add(1, 2); // => 3\r\n *\r\n * // It's also curried\r\n *\r\n * const adder = add(2);\r\n *\r\n * adder(3); // => 5\r\n * adder(2); // => 4\r\n */\r\nexport default curry((a, b) => a + b);\r\n","import curry from './curry';\n\n/**\n * @name and\n * @since v2.0.0\n * @category Function\n * @sig Boolean -> Boolean -> Boolean\n * @description\n * Runs an and comparison on the two values passed in\n * @param {Boolean} a The first boolean to compare\n * @param {Boolean} b The second boolean to compare\n * @return {Boolean} The evaluated outcome of the parameters\n *\n * @example\n * and(true, true); // => true\n * and(true, false); // => false\n * and(false, false); // => false\n */\nexport default curry((a, b) => a && b);\n","\r\nexport default x => Object.prototype.toString.call(x) === '[object Object]';\r\n","/**\r\n * @name not\r\n * @since v0.1.0\r\n * @category Function\r\n * @sig * -> Boolean\r\n * @description Returns boolean based on if the value is not\r\n * @param  {Boolean} x The values to compare against\r\n * @return {Boolean}   Returns boolean back based on the results\r\n *\r\n * @example\r\n * const reverse = not(true); // => false\r\n */\r\nexport default x => !x;\r\n","import curry from './curry';\r\nimport not from './not';\r\n\r\n/**\r\n * @name complement\r\n * @since v0.6.0\r\n * @category Function\r\n * @description\r\n * Takes a function and returns a new function that when called returns the opposite truthy/falsy value of\r\n * what was passed in.\r\n * @param {Function} fn The function we want to apply the complement of\r\n * @param {Any} a The value our functionality is being ran against\r\n * @return {Function} Returns the opposite function back\r\n *\r\n * @example\r\n * const isNot = complement(is(String));\r\n *\r\n * isNot(1); // => true\r\n * isNot('test'); // => false\r\n */\r\nexport default curry((fn, a) => not(fn(a)));\r\n","/**\r\n * @name isNil\r\n * @since v1.0.0\r\n * @category Relation\r\n * @sig a -> Boolean\r\n * @description Checks if the value is a null value\r\n * @param  {Any}  x The value to run our test against\r\n * @return {Boolean} Returns a boolean based on the check\r\n *\r\n * @example\r\n * isNill(null); // => true\r\n * isNill(); // => true\r\n * isNill(1); // => false\r\n */\r\nexport default x => x == null; // eslint-disable-line eqeqeq\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name contains\r\n * @since v0.5.0\r\n * @category Array\r\n * @sig a → Array a → Boolean\r\n * @description\r\n * Checks to see if the provided list contains at at least 1 of the provided value within it\r\n * @param {Any} a The value we want to search the list for\r\n * @param {Array} list The list we want to search through\r\n * @return {Boolean} A Boolean based on if the value is found or not\r\n *\r\n * @example\r\n * contains(3, [1, 2, 3]); // => true\r\n *\r\n * // It is also curried\r\n *\r\n * const checker = contains(3);\r\n *\r\n * checker([1, 2, 3]); // => true\r\n */\r\nexport default curry((a, list) =>\r\n  list.indexOf(a) !== -1);\r\n","import curry from './curry';\r\nimport isNil from './isNil';\r\n\r\n/**\r\n * @name defaults\r\n * @since v0.5.0\r\n * @category Object\r\n * @sig {a} -> {b} -> {c}\r\n * @description\r\n * Applies default properties to an object that does not contain the smae or contains falsey values on those properties\r\n * @param {Object} def The default object to reference\r\n * @param {Object} data The data object to loop through\r\n * @return {Object} A New object\r\n *\r\n * @example\r\n *\r\n * defaults({ test: 1, thing: 2 }, { thing: 4 }); // => { test: 1, thing: 4 }\r\n *\r\n * // It's also curried\r\n *\r\n * const def = defaults({ test: 1, thing: 2 });\r\n *\r\n * def({ thing: 4 }); // => { test: 1, thing: 4 }\r\n */\r\nexport default curry((def, data) => {\r\n  const keys = Object.keys(def);\r\n\r\n  return keys.reduce((acc, prop) => {\r\n    if (isNil(acc[prop])) {\r\n      acc[prop] = def[prop];\r\n    }\r\n\r\n    return acc;\r\n  }, data);\r\n});\r\n","/**\n * @name flatten\n * @since v0.4.0\n * @category Array\n * @sig [a] -> [b]\n * @description Flattens an array to a single level\n * @param  {Array} list The array list we want to flatten into a single level array\n * @return {Array} Returns an array flattened to a single level\n *\n * @example\n * const results = flatten( [[1, 2, 3], [4, 5, 6]] ); // => [1, 2, 3, 4, 5, 6]\n * const results = flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);\n * // => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ]\n */\nconst flatten = list =>\n  list.reduce((acc, x) =>\n    acc.concat(Array.isArray(x) ? flatten(x) : x), []);\n\nexport default flatten;\n","import curry from './curry';\r\nimport flatten from './flatten';\r\n\r\n/**\r\n * @name difference\r\n * @since v2.0.0\r\n * @category Array\r\n * @sig Array a -> Array a -> Array a\r\n * @description Returns an array with the elements present in the first that are not in the second\r\n * @param {Array} a The list to search through\r\n * @param {Array} b The second list to compare against\r\n * @return {Array} An array of elements present in the first that are not in the second\r\n *\r\n * @example\r\n *\r\n * difference([1, 2, 3], [1]); // => [2, 3];\r\n *\r\n * // It's also curried\r\n * const diff = difference([1, 2, 3]);\r\n *\r\n * diff([1]); // => [2, 3]\r\n */\r\nexport default curry((a, [...rest]) => {\r\n  const flatRest = flatten(rest);\r\n\r\n  return a.filter(x => flatRest.indexOf(x) === -1);\r\n});\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name div\r\n * @since v2.0.0\r\n * @category Number\r\n * @sig Number -> Number -> Number\r\n * @description Divides the provided items\r\n * @param {Number} a The dividend of the division problem\r\n * @param {Number} b The divisor which the dividend will be divided by\r\n * @return {Number} The quotient of the two numbers\r\n *\r\n * @example\r\n * div(2, 1); // => 2\r\n *\r\n * // It's also curried\r\n *\r\n * const divide = div(15);\r\n *\r\n * divide(3); // => 5\r\n * divide(5); // => 3\r\n */\r\nexport default curry((a, b) => a / b);\r\n","/**\r\n * @name type\r\n * @since v0.1.0\r\n * @category Function\r\n * @sig a -> Boolean\r\n * @description Finds the type of the sent value\r\n * @param  {Any} x The value to test\r\n * @return {String}   Returns the string of the value type\r\n *\r\n * @example\r\n * type({}); // => 'Object'\r\n * type([]); // => 'Array'\r\n * type(null); // => 'Null'\r\n * type(undefined); // => 'Undefined'\r\n * type('hi'); // => 'String'\r\n * type(1); // => 'Number'\r\n * type(/1/g); // => 'RegExp'\r\n * type(new Date()); // => 'Date'\r\n * type(true); // => 'Boolean'\r\n */\r\nexport default x => {\r\n  if (x === null) {\r\n    return 'Null';\r\n  }\r\n  if (x === undefined) { // eslint-disable-line no-undefined\r\n    return 'Undefined';\r\n  }\r\n\r\n  return Object.prototype.toString.call(x).slice(8, -1);\r\n};\r\n","import isNil from './isNil';\r\n\r\n/**\r\n * @name ensureArray\r\n * @since v1.0.0\r\n * @category Array\r\n * @description\r\n * Ensures that the value passed in is an array, if not it will make it an array or\r\n * pass back an empty array if the value if undefined/null\r\n * @param {Any} x The value to ensure\r\n * @return {Array} Returns a new array\r\n *\r\n * @example\r\n * ensureArray(1); // => [1]\r\n * ensureArray(); // => []\r\n * ensureArray(null); // => []\r\n * ensureArray('test'); // => ['test']\r\n */\r\nexport default x => {\r\n  if (Array.isArray(x)) {\r\n    return x;\r\n  }\r\n\r\n  if (isNil(x)) {\r\n    return [];\r\n  }\r\n\r\n  return [x];\r\n};\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name every\r\n * @since v0.6.0\r\n * @category Array\r\n * @sig (a -> Boolean) -> [a] -> Boolean\r\n * @description\r\n * Loops through a provided list verifying that every value evaluates to a truthy value.\r\n * @param {Function} fn The function to send our values to for validation\r\n * @param {Array} x The list we are to loop through\r\n * @return {Boolean} If all values passed will return true else false\r\n *\r\n * @example\r\n * const data = [1, 2, 3, 4];\r\n *\r\n * every(x => x > 0, data); // => true\r\n * every(x => x < 3, data); // => false\r\n *\r\n * // It is also curried\r\n *\r\n * const run = every(x => x > 0);\r\n *\r\n * run([1, 2, 3]); // => true\r\n * run([-1, 0, 1]); // => false\r\n */\r\nexport default curry((fn, x) => x.every(fn));\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name filter\r\n * @since v0.5.0\r\n * @category Array\r\n * @sig Filterable f => (a → Boolean) → f a → f a\r\n * @description Filter through a filterable data piece using the provided function\r\n * @param {Function} fn The predicate function to run on our values\r\n * @param {Array|Object} list The filterable list to go through\r\n * @return {Array|Object} Returns a new Array or Object based on the type of list provided\r\n *\r\n * @example\r\n * const isEven = n => n % 2 === 0;\r\n *\r\n * filter(isEven, [1, 2, 3, 4]); // => [2, 4]\r\n *\r\n * // Is also curried\r\n *\r\n * const filterer = filter(isEven);\r\n *\r\n * filterer([1, 2, 3, 4]); // => [2, 4]\r\n */\r\nexport default curry((fn, list) => list.filter(fn));\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name find\r\n * @since v0.2.0\r\n * @category Array\r\n * @sig (a -> Boolean) -> [a] -> a | Boolean\r\n * @description Find an item based on the function sent in and its list\r\n * @param  {Function} f The function used/called during the find\r\n * @param  {Object} x The list we want to search through\r\n * @return {Any} Returns either the found item, or false if nothing is found\r\n *\r\n * @example\r\n * const obj = find(v => v.val === 'test', {val: 'test'}); // => 'test'\r\n * const arr = find(v => v.val === 'test', [{val: 'test'}, {val: 'none'}]); // => { val: 'test' }\r\n *\r\n * // find is also curried\r\n *\r\n * const finder = find(v => v.val === 'test');\r\n *\r\n * finder({val: 'test'}); // => 'test'\r\n * finder([{val: 'test'}, {val: 'none'}]); // => { val: 'test' }\r\n */\r\nexport default curry((fn, list) => {\r\n  let idx = 0;\r\n  const len = list.length;\r\n\r\n  while (idx < len) {\r\n    if (fn(list[idx])) {\r\n      return list[idx];\r\n    }\r\n\r\n    idx += 1;\r\n  }\r\n\r\n  return false;\r\n});\r\n","import curry from './curry';\n\nconst search = (h, n, { nLen, hLen }) => { // eslint-disable-line complexity\n  outer: for (let i = 0, j = 0; i < nLen; i++) {\n    const nch = n.charCodeAt(i);\n\n    while (j < hLen) {\n      if (h.charCodeAt(j++) === nch) {\n        continue outer;\n      }\n    }\n\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * @name fuzzySearch\n * @since v0.3.0\n * @sig a -> Boolean\n * @category Function\n * @description Fuzzy search setup to look find things fast and effective\n * @param  {String} h The value to search for\n * @param  {String} n The Item to search\n * @return {Boolean} Returns a boolean determined by if the value is found or not by the search\n *\n * @example\n * const results = fuzzySearch('test', 'te'); // => true\n * const results = fuzzySearch('testing', 'dog'); // => false\n *\n * // search is also curried\n *\n * const searcher = fuzzySearch('test');\n * const results = searcher('te'); // => true\n */\nexport default curry((h, n) => {\n  const hLen = h.length;\n  const nLen = n.length;\n\n  if (nLen > hLen) {\n    return false;\n  }\n\n  if (nLen === hLen) {\n    return n === h;\n  }\n\n  return search(h, n, {\n    nLen,\n    hLen\n  });\n});\n","import curry from './curry';\r\n\r\n/**\r\n * @name gcd\r\n * @since v2.0.0\r\n * @category Number\r\n * @sig Number -> Number -> Number\r\n * @description\r\n * Determines the greatest common denominator of the numbers passed in\r\n * @param {Number} a The First number to use\r\n * @param {Number} b The Second number to use\r\n * @return {Number} The Greatest Common Denominator\r\n *\r\n * @example\r\n * gcd(80, 90); // => 10\r\n * gcd(20, 600); // => 20\r\n *\r\n * // It's also curried\r\n *\r\n * const a = gcd(80);\r\n *\r\n * a(90); // => 10\r\n * a(93); // => 1\r\n*/\r\nconst gcd = curry((a, b) => {\r\n  if (!b) {\r\n    return a;\r\n  }\r\n\r\n  return gcd(b, a % b);\r\n});\r\n\r\nexport default gcd;\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name has\r\n * @since v0.2.0\r\n * @category Object\r\n * @sig s -> {s: x} -> Boolean\r\n * @description Determines if the object has a property\r\n * @param  {String} prop The prop to look for\r\n * @param  {Object} obj The Object we are searching\r\n * @return {Boolean} Returns based on if the prop is found or not\r\n *\r\n * @example\r\n * const obj = has('thing', { test: 1, thing: 2 }); // => true\r\n *\r\n * // has is also curried\r\n *\r\n * const propSet = has('thing');\r\n *\r\n * propSet({ test: 1, thing: 2 }); // => true\r\n */\r\nexport default curry((prop, obj) =>\r\n  Object.prototype.hasOwnProperty.call(obj, prop));\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name identical\r\n * @since v0.1.0\r\n * @category Relation\r\n * @sig a -> a-> Boolean\r\n * @description Performs a check to see if the items are identical in the sense that they reference the same memory\r\n * @param  {Any} a The first value to compare\r\n * @param  {Any} b The second value to compare\r\n * @return {Boolean}   Returns a boolean based on the check\r\n *\r\n * @example\r\n * const obj = identical(NaN, NaN); // => true\r\n *\r\n * // Identical is also curried\r\n *\r\n * const test = identical(NaN); // => Gives back a function\r\n * test(NaN); // => true\r\n */\r\nexport default curry((a, b) => {\r\n  if (a === b) {\r\n    // +0 !== -0\r\n    return a !== 0 || 1 / a === 1 / b;\r\n  }\r\n\r\n  // NaN === NaN\r\n  return a !== a && b !== b; // eslint-disable-line no-self-compare\r\n});\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name includes\r\n * @since v2.0.0\r\n * @category String\r\n * @sig String -> String -> Boolean\r\n * @description\r\n * Goes through a provided string and attempts to find the provided value within it\r\n * @param {String} str The string we want to search through\r\n * @param {String} a The string we want to find\r\n * @return {Boolean} Based on if the string is found or not\r\n * @example\r\n * includes('cow', 'small brown cow'); // => true\r\n * includes('cow', 'Small Brown Cow'); // => true\r\n *\r\n * const x = 'cow';\r\n *\r\n * includes('cow', `small brown ${x}`); // => true\r\n *\r\n * // It's also curried\r\n *\r\n * const checker = includes('cow');\r\n *\r\n * checker('small brown cow'); // => true\r\n */\r\nexport default curry((a, str) => str.indexOf(a) !== -1);\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name intersection\r\n * @since v2.0.1\r\n * @category Array\r\n * @sig Array a -> Array a -> Array a\r\n * @description Returns an array containing elements present in both arrays\r\n * @param {Array} a Our first array value to compare with\r\n * @param {Array} b Our second array value to compare with\r\n * @return {Array} A new array containing values that both arrays had\r\n *\r\n * @example\r\n * intersection([1, 2, 3, 4], [3, 4, 5, 6]); // => [3, 4]\r\n *\r\n * // It's also curried\r\n *\r\n * const inter = intersection([1, 2, 3, 4]);\r\n *\r\n * inter([3, 4, 5, 6]); // => [3, 4]\r\n */\r\nexport default curry((a, b) => a.filter(x => b.indexOf(x) !== -1));\r\n","import curry from './curry';\nimport isNil from './isNil';\n\n// To keep checks strict we sadly have to use this\n/* eslint-disable no-undefined */\n\n/**\n * @name is\n * @since v0.5.0\n * @category Function\n * @sig (* -> {*}) -> a -> Boolean\n * @description\n * See if an object is an instance of the supplied constructor, this will also check up the inheritence chain\n * @param {Object} Ctor A Constructor\n * @param {*} x The value to test\n * @return {Boolean}\n *\n * @example\n * is(Object, {}); // => true\n * is(Array, []); // => true\n * is(String, ''); // => true\n * is(Number, 0); // => true\n * is(Boolean, true); // => true\n * is(Function, a => a); // => true\n * is(RegExp, /[0-9]/g); // => true\n *\n * // It is curried as well\n *\n * const isObject = is(Object);\n *\n * isObject({}); // => true\n *\n * // Gotchas\n * // Since it is a light check you need to watch how you run into sitatuions like this\n * is(Object, {}); // => true\n * is(Object, []); // => true\n */\nexport default curry((Ctor, x) => (!isNil(x) && x.constructor === Ctor) || x instanceof Ctor);\n","export default iter => {\n  const list = [];\n  let next = '';\n\n  while (!(next = iter.next()).done) {\n    list.push(next.value);\n  }\n\n  return list;\n};\n","import arrayFromIterator from './array-from-iterator';\nimport functionName from './function-name';\nimport has from '../has';\nimport identical from '../identical';\nimport type from '../type';\n\nconst nullTypeCheck = (a, b) => a === null || b === null || type(a) !== type(b);\n\n// Contain the bulk of basic regex logic\nconst regexCheck = (a, b) => {\n  const vals = ['source', 'global', 'ignoreCase', 'multiline', 'sticky', 'unicode'];\n\n  for (let i = 0; i < vals.length; i++) {\n    const p = vals[i];\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n// Try to simplify our switch with a function narrowing down our options\nconst typeCheck = a => {\n  const allTypes = {\n    complex: ['Arguments', 'Array', 'Object'],\n    simple: ['Boolean', 'Number', 'String'],\n    date: ['Date'],\n    err: ['Error'],\n    regex: ['RegExp'],\n    map: ['Map', 'Set'],\n    other: ['Int8Array', 'Uint8Array', 'Uint8ClampedArray',\n      'Int16Array', 'Uint16Array', 'Int32Array',\n      'Uint32Array', 'Float32Array', 'Float64Array', 'ArrayBuffer']\n  };\n\n  for (const prop in allTypes) {\n    const currType = allTypes[prop];\n\n    if (currType.indexOf(a) !== -1) {\n      return prop;\n    }\n  }\n\n  return '';\n};\n\n// The vast functionality of the extremely strict equals functionality\nconst equal = (a, b, stackA = [], stackB = []) => { // eslint-disable-line complexity\n  if (identical(a, b)) {\n    return true;\n  }\n\n  if (nullTypeCheck(a, b)) {\n    return false;\n  }\n\n  switch (typeCheck(type(a))) {\n    case 'complex':\n      if (typeof a.constructor === 'function' &&\n      functionName(a.constructor) === 'Promise') {\n\n        return a === b;\n      }\n      break;\n    case 'simple':\n      if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {\n        return false;\n      }\n      break;\n    case 'date':\n      if (!identical(a.valueOf(), b.valueOf())) {\n        return false;\n      }\n      break;\n    case 'err':\n      return a.name === b.name && a.message === b.message;\n    case 'regex':\n      if (!regexCheck(a, b)) {\n        return false;\n      }\n      break;\n    case 'map':\n      if (!equal(arrayFromIterator(a.entries()), arrayFromIterator(b.entries()), stackA, stackB)) {\n        return false;\n      }\n      break;\n    case 'other':\n      break;\n    default:\n      return false;\n  }\n\n  const keysA = Object.keys(a);\n\n  if (keysA.length !== Object.keys(b).length) {\n    return false;\n  }\n\n  let idx = stackA.length - 1;\n  let idy = keysA.length - 1;\n\n  while (idx >= 0) {\n    if (stackA[idx] === a) {\n      return stackB[idx] === b;\n    }\n    idx -= 1;\n  }\n\n  stackA.push(a);\n  stackB.push(b);\n\n  while (idy >= 0) {\n    const key = keysA[idy];\n\n    if (!(has(key, b) && equal(b[key], a[key], stackA, stackB))) {\n      return false;\n    }\n    idy -= 1;\n  }\n  stackA.pop();\n  stackB.pop();\n\n  return true;\n};\n\nexport default equal;\n","export default f => {\n  const match = String(f).match(/^function (\\w*)/);\n\n  return match == null ? '' : match[1]; // eslint-disable-line\n};\n","import curry from './curry';\r\nimport gcd from './gcd';\r\n\r\n/**\r\n * @name lcm\r\n * @since v2.0.0\r\n * @category Number\r\n * @sig Number -> Number -> Number\r\n * @description Finds the least common multiple of the provided numbers\r\n * @param {Number} a The first number to use\r\n * @param {Number} b The second number to use\r\n * @return {Number} The least common multiple of the two numbers\r\n *\r\n * @example\r\n *\r\n * lcm(90, 70); // => 630\r\n * lcm(91, 4); // => 364\r\n *\r\n * // It's also curried\r\n *\r\n * const a = lcm(90);\r\n *\r\n * a(70); // => 630\r\n * a(4); // => 180\r\n */\r\nexport default curry((a, b) =>\r\n  Math.abs(Math.floor(a / gcd(a, b) * b))\r\n);\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name map\r\n * @since v0.6.0\r\n * @category Array\r\n * @sig (a -> b) -> f a -> f b\r\n * @description\r\n * Takes a function and applies it to all of the values within the provided list,\r\n * and brings back a new list of the same type.\r\n * @param {Function} fn The function to run against the values in our functor\r\n * @param {Array|Object} list The list to iterate through\r\n * @return {Array|Object} The new Array or Object that was created\r\n *\r\n * @example\r\n * const dbl = n => n * 2;\r\n *\r\n * map(dbl, [1, 2, 3]); // => [2, 4, 6]\r\n *\r\n * // It's also curried\r\n *\r\n * const dbler = map(dbl);\r\n *\r\n * dbler([1, 2, 3]); // => [2, 4, 6]\r\n */\r\nexport default curry((fn, list) => list.map(fn));\r\n\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name nth\r\n * @since v0.1.0\r\n * @category Array\r\n * @sig Number -> Array a -> Maybe a\r\n * @description Returns the nth element of the given list or string.\r\n * @param  {Number} o How much to offset the value\r\n * @param  {Array} x   The Array or list to crawl through\r\n * @return {Number} Returns the value of the found index\r\n *\r\n * @example\r\n * nth(3, [1, 2, 3, 4, 5, 6, 7]); // => 4\r\n *\r\n * // nth is curried\r\n *\r\n * const third = nth(2);\r\n *\r\n * third([1, 2, 3, 4, 5]); // => 3\r\n */\r\nexport default curry((o, x) => {\r\n  const idx = o < 0 ? x.length + o : o;\r\n\r\n  return x[idx];\r\n});\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name mul\r\n * @since v2.0.0\r\n * @category Number\r\n * @sig Number -> Number -> Number\r\n * @description Multiplies the provided items\r\n * @param {Number} a The first factor to multiply with\r\n * @param {Number} b The second factor to multiply with\r\n * @return {Number} The product of the numbers\r\n *\r\n * @example\r\n * mul(2, 1); // => 2\r\n *\r\n * // It's also curried\r\n *\r\n * const multiply = mul(5);\r\n *\r\n * multiply(3); // => 15\r\n * multiply(2); // => 10\r\n */\r\nexport default curry((a, b) => a * b);\r\n","import curry from './curry';\r\nimport ensureArray from './ensureArray';\r\n\r\n/**\r\n * @name omit\r\n * @since v0.4.0\r\n * @category Object\r\n * @sig [String] -> {String: *} → {String: *}\r\n * @description Create a new Array/Object by omitting the requested values\r\n * @param  {Array} key The key(s) in which to omit from the data\r\n * @param  {Object} x The object to search through and filter\r\n * @return {Object} Returns the newly created data without the omitted values\r\n *\r\n * @example\r\n * const obj = omit('test', { test: '3432', thing: 123 }); // => { thing: 123 }\r\n * const arr = omit(['a', 'b'], { a: 1, b: 2, c: 3}); // => { c: 3 }\r\n *\r\n * // omit is curried\r\n *\r\n * const omitKeys = omit('test');\r\n *\r\n * omitKeys({ test: '3432', thing: 123 }); // => { thing: 123 }\r\n */\r\nexport default curry((key, x) => {\r\n  const keyArr = ensureArray(key);\r\n\r\n  return Object.keys(x).reduce((acc, prop) => {\r\n    if (keyArr.indexOf(prop) === -1) {\r\n      acc[prop] = x[prop];\r\n    }\r\n\r\n    return acc;\r\n  }, {});\r\n});\r\n","import curry from './curry';\n\n/**\n * @name or\n * @since v2.0.0\n * @category Function\n * @sig Boolean -> Boolean -> Boolean\n * @description\n * Runs an or comparison on the two values passed in\n * @param {Boolean} a The first boolean to compare\n * @param {Boolean} b The second boolean to compare\n * @return {Boolean} The evaluated outcome of the parameters\n *\n * @example\n * or(true, true); // => true\n * or(true, false); // => true\n * or(false, false); // => false\n */\nexport default curry((a, b) => a || b);\n","import curry from './curry';\r\n\r\n/**\r\n * @name partition\r\n * @since v0.5.0\r\n * @category Array\r\n * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]\r\n * @description\r\n * Takes a predicate function and a list or filterable data object and returns the pair.\r\n * One contains the data which passed the predicate function, the other the values that did not.\r\n * @param {Function} fn The predicate function to determine which side an element belongs to\r\n * @param {Array} list The list or other filterable to partition through\r\n * @return {Array} An array containing the first set of elements that passed the predicate function,\r\n * And a second that did not\r\n *\r\n * @example\r\n * partition(is(String), ['foo', 'bar', 100]); // => [ ['foo', 'bar'], [100] ]\r\n *\r\n * // Is curried as well\r\n *\r\n * const part = partition(is(String));\r\n *\r\n * part(['foo', 'bar', 100]); // => [ ['foo', 'bar'], [100] ]\r\n */\r\nexport default curry((fn, list) =>\r\n  list.reduce(([pass, fail], v) =>\r\n    fn(v) ? [pass.concat(v), fail] : [pass, fail.concat(v)], [[], []]));\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name pipe\r\n * @since v2.0.0\r\n * @category Function\r\n * @sig Array (a -> b) -> a -> b\r\n * @description Applies a sequence of transformations over a value.\r\n * @param {Array} list The array of functions to apply to our value\r\n * @param {Any} a The value to apply our functions too\r\n * @return {Any} The transformed value\r\n *\r\n * @example\r\n * pipe([add(2), mul(2)], 10); // => 24\r\n *\r\n * // It's also curried\r\n *\r\n * const piper = pipe([add(2), mul(2)]);\r\n *\r\n * piper(10); // => 24\r\n */\r\nexport default curry((list, a) =>\r\n  list.reduce((acc, fn) => fn(acc), a));\r\n","import curry from './curry';\nimport isObject from './_internals/isObject';\n\n/**\n * @name pluck\n * @since v0.6.0\n * @category Object\n * @sig k -> f {k: v} -> f v\n * @description\n * Returns a new list of values based on the provided property name and provided object\n * @param {String} p The property to look for\n * @param {Object} list The list to iterate through\n * @return {Object} The new list which will be the same type as the list provided\n *\n * @example\n * pluck('val', { a: { val: 3 }, b: { val: 5 } }); // => { a: 3, b: 5 }\n *\n * // It is also curried\n * const plucker = pluck('a');\n *\n * plucker([{ a: 1 }, { a: 2 }]); // => [1, 2]\n */\nconst pluck = curry((p, list) =>\n  Object.keys(list).reduce((acc, v) => {\n    const val = list[v];\n\n    if (isObject(val)) {\n      acc.push(...pluck(p, val));\n\n      return acc;\n    }\n\n    if (v === p) {\n      acc.push(val);\n    }\n\n    return acc;\n  }, []));\n\nexport default pluck;\n","import curry from './curry';\n\n/**\n * @name prepend\n * @since v0.5.0\n * @category Array\n * @sig a -> [a] -> [a]\n * @description Returns a new list with the provided value at the front of the given list\n * @param  {Any} x The value we want to put at the front of our list\n * @param  {Array} list The Array or list to prepend to\n * @return {Array} A new array\n *\n * @example\n * const i = nth(3, [1, 2, 3, 4, 5, 6, 7]); // => 4\n *\n * // nth is curried\n *\n * const third = nth(2);\n *\n * third([1, 2, 3, 4, 5]); // => 3\n */\nexport default curry((x, list) => [x, ...list]);\n","import curry from './curry';\r\n\r\n/**\r\n * @name prop\r\n * @since v0.6.0\r\n * @category Object\r\n * @sig k -> {k: v} -> v | Undefined\r\n * @description\r\n * Brings back the indicated property of an object if it exists\r\n * @param {Array} p The array path of the property we are looking for\r\n * @param {Object} obj The object to search through\r\n * @return {Any} The value that exists at 'obj.p'\r\n *\r\n * @example\r\n * prop('thing', { thing: 'test' }); // => 'test'\r\n * prop('thing', {}); // => undefined\r\n * map(prop('a'), [{ a: 1 }, { a: 2 }, { a: 3 }]); // => [1, 2, 3]\r\n *\r\n * // It is also curried\r\n *\r\n * const proper = prop('a');\r\n *\r\n * proper({ a: 1, b: 2 }); // => 1\r\n */\r\nconst prop = curry((p, obj) => obj[p]);\r\n\r\nexport default prop;\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name reduce\r\n * @since v2.0.0\r\n * @category Array\r\n * @sig (a -> b -> b) -> b -> Array a -> b\r\n * @description\r\n * Accepts an array and runs a reduce based on the passed values\r\n * @param {Function} fn The function to run with the reduce\r\n * @param {Any} init The empty initial state of the reduce accumulator\r\n * @param {Array} list The list to run our reduce against\r\n * @return {Any} Returns based on the original init parameter that is passed in\r\n *\r\n * @example\r\n * reduce((acc, n) => acc + n, 0, [1, 2, 3, 4, 5]); // => 15\r\n * reduce((acc, n) => {\r\n    if (typeof n === 'number') {\r\n      acc.push(n);\r\n    }\r\n\r\n    return acc;\r\n  }, [], ['', 1, 2, '0', 3]); // => [1, 2, 3]\r\n */\r\nexport default curry((fn, init, list) => list.reduce(fn, init));\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name reject\r\n * @since v0.5.0\r\n * @category Array\r\n * @sig Filterable f => (a → Boolean) → f a → f a\r\n * @description\r\n * Filter through a filterable data piece using the provided function returns only those that fail the function test\r\n * @param {Function} fn The predicate function to run on our values\r\n * @param {Array} list The filterable list to go through\r\n * @return {Array} Returns a new Array or Object based on the type of list provided\r\n *\r\n * @example\r\n * const isEven = n => n % 2 === 0;\r\n *\r\n * reject(isEven, [1, 2, 3, 4]); // => [1, 3]\r\n *\r\n * // Is also curried\r\n *\r\n * const rejecter = reject(isEven);\r\n *\r\n * rejecter([1, 2, 3, 4]); // => [1, 3]\r\n */\r\nexport default curry((fn, list) =>\r\n  list.filter(v => !fn(v)));\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name removeAt\r\n * @since v0.1.0\r\n * @category Array\r\n * @sig Number -> [a] -> [b]\r\n * @description Remove an item from a certain point in the index\r\n * @param  {Number} i   The index number to remove from\r\n * @param  {Array} x The array in question\r\n * @return {Array}     returns the modified array back\r\n *\r\n * @example\r\n * const test = removeAt(2, [1, 2, 3, 4]); // => [1, 2, 4]\r\n *\r\n * // This is also a curried method\r\n *\r\n * const remover = removeAt(2);\r\n * const test = remover([1, 2, 3, 4]); // => [1, 2, 4]\r\n */\r\nexport default curry((i, x) =>\r\n  [...x.slice(0, i), ...x.slice(i + 1)]);\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name replaceAt\r\n * @since v0.1.0\r\n * @category Array\r\n * @sig Number -> a -> [b] -> [c]\r\n * @description Add an item to an array within a certain index of the array\r\n * @param  {Number} i The index number to add at\r\n * @param  {Any} t What we want to add to our array\r\n * @param  {Array} x The array in question\r\n * @return {Array} Returns the modified array\r\n *\r\n * @example\r\n * replaceAt(2, 10, [1, 2, 3]); // => [1, 2, 10]\r\n *\r\n * // You can also use it as a curried method\r\n *\r\n * const replacer = replaceAt(2, 10);\r\n *\r\n * replacer([1, 2, 3]); // => [1, 2, 10]\r\n *\r\n * // This can be taken further like so\r\n *\r\n * const index = replaceAt(2);\r\n * const val = index(10);\r\n * val([1, 2, 3]); // => [1, 2, 10]\r\n */\r\nexport default curry((i, t, x) =>\r\n  [...x.slice(0, i), t, ...x.slice(i + 1)]);\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name round\r\n * @since v2.2.0\r\n * @category Number\r\n * @sig Number -> Number -> Number\r\n * @description Round a number using exponent rounding\r\n * @param {Number} precision The precision we want the number to be rounded to\r\n * @param {Number} num The number we are going to round\r\n * @return {Number} The rounded number to the desired precision\r\n *\r\n * @example\r\n * round(2, 112.336); // => 112.34\r\n * round(3, 112.3354); // => 112.335\r\n *\r\n * // It is curried\r\n * const rounder = round(3);\r\n *\r\n * rounder(122.4456); // => 112.446\r\n * rounder(122.332); // => 122.332\r\n */\r\nexport default curry((precision, num) => {\r\n  const roundedNum = (Math.round(`${num}e${precision}`));\r\n\r\n  return Number(`${roundedNum}e-${precision}`);\r\n});\r\n\r\n","import curry from './curry';\n\n/**\n * @name slice\n * @since v2.0.0\n * @category Array\n * @sig Number -> Number -> Array a -> Array a\n * @description\n * Returns a subset of an array based on the provided indexes\n * @param {Number} a The index at which to begin extraction\n * @param {Number} b The index for what the extraction goes to. However does not extract\n * @return {Array} The newly created subset Array\n *\n * @example\n * slice(1, 3, [1, 2, 3, 4, 5]); // => [2, 3]\n *\n * // It is curried\n *\n * const slicer = slice(1, 3);\n *\n * slicer([1, 2, 3, 4, 5]); // => [2, 3]\n */\nexport default curry((a, b, list) => list.slice(a, b));\n","import curry from './curry';\r\n\r\n/**\r\n * @name some\r\n * @since v0.6.0\r\n * @category Array\r\n * @sig (a -> Boolean) -> [a] -> Boolean\r\n * @description\r\n * Loops through a provided list verifying that at least some values evaluates to a truthy value.\r\n * @param {Function} fn The function to send our values to for validation\r\n * @param {Array} x The list we are to loop through\r\n * @return {Boolean} If any values passed will return true else false\r\n *\r\n * @example\r\n * const data = [1, 2, 3, 4];\r\n *\r\n * some(x => x > 0, data); // => true\r\n * some(x => x < 3); // => true\r\n * some(x => x < 0, data); // => false\r\n *\r\n * // It is also curried\r\n *\r\n * const run = some(x => x > 0);\r\n *\r\n * run([1, 2, 3]); // => true\r\n * run([-1, 0, 1]); // => true\r\n * run([-3, -2, -1]); // => false\r\n */\r\nexport default curry((fn, x) => x.some(fn));\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name sort\r\n * @since v2.0.0\r\n * @category Array\r\n * @sig ((a, a) -> Number) -> Array a -> Array a\r\n * @description Uses a comparison function to sort an array\r\n * @param {Function} fn The function used to sort the array\r\n * @param {Array} a The array to be sorted\r\n * @return {Array} A new sorted array\r\n *\r\n * @example\r\n * sort((a, b) => a - b, [99, 23, 10, 53, 1]); // => [1, 10, 23, 53, 99]\r\n *\r\n * // It's also curried\r\n *\r\n * const sorter = sort((a, b) => a - b);\r\n *\r\n * sorter([99, 23, 10, 53, 1]); // => [1, 10, 23, 53, 99]\r\n * sorter([5, 3, 4, 6, 2, 1]); // => [1, 2, 3, 4, 5, 6]\r\n */\r\nexport default curry((fn, a) => a.slice().sort(fn));\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name sub\r\n * @since v2.0.0\r\n * @category Number\r\n * @sig Number -> Number -> Number\r\n * @description Subtracts the provided items\r\n * @param {Number} a The number to subtract from\r\n * @param {Number} b The number to subtract with\r\n * @return {Number} The difference of the numbers\r\n *\r\n * @example\r\n * sub(2, 1); // => 1\r\n *\r\n * // It's also curried\r\n *\r\n * const subtract = sub(5);\r\n *\r\n * subtract(3); // => 2\r\n * subtract(2); // => 3\r\n */\r\nexport default curry((a, b) => a - b);\r\n","\r\n/**\r\n * @name trim\r\n * @since v2.0.0\r\n * @category String\r\n * @sig String a -> String a\r\n * @description\r\n * Accepts a string value and trims it's white space\r\n * @param {String} str The string to trim\r\n * @return {String} The trimmed string\r\n * @example\r\n * trim('my new cow   '); // => 'my new cow'\r\n * trim('   new things   '); // => 'new things'\r\n */\r\nexport default str => str.trim();\r\n","import curry from './curry';\r\nimport flatten from './flatten';\r\n\r\n/**\r\n * @name union\r\n * @since v2.0.0\r\n * @category Array\r\n * @sig Array a -> Array a -> Array a\r\n * @description\r\n * Computes the union of the passed-in arrays: the list of unique items,\r\n * in order, that are present in one or more of the arrays.\r\n * @param {Array} a An array to put through combining\r\n * @param {Array} rest The rest of the arrays\r\n * @return {Array} A new array of unique values from each of the passed in arrays\r\n *\r\n * @example\r\n *\r\n * union([1, 2, 3], [3, 4, 5]); // => [1, 2, 3, 4, 5]\r\n * union([1, 2, 3], [[3, 4, 5], [4, 5, 6]]); // => [1, 2, 3, 4, 5, 6]\r\n *\r\n * // It's also curried\r\n *\r\n * const un = union([1, 2, 3]);\r\n *\r\n * un([3, 4, 5]); // => [1, 2, 3, 4, 5]\r\n * un([[3, 4, 5], [4, 5, 6]]); // => [1, 2, 3, 4, 5, 6]\r\n */\r\nexport default curry((a, [...rest]) =>\r\n  a.concat(flatten(rest)).reduce((acc, v) => acc.indexOf(v) === -1 ? acc.concat(v) : acc, []));\r\n","import curry from './curry';\r\n\r\n/**\r\n * @name uniq\r\n * @since v2.0.0\r\n * @category Array\r\n * @sig (a -> b) -> Array a -> Array a\r\n * @description Returns an array of unique values from the applied function\r\n * @param {Function} fn The function to apply\r\n * @param {Array} list The list to sift through\r\n * @return {Array} An array of uniq values from the provided function\r\n *\r\n * @example\r\n *\r\n * uniq(x => x > 2, [1, 2, 3, 4, 5]); // => [3, 4, 5]\r\n *\r\n * // It is also curried\r\n *\r\n * const uq = uniq(x => x > 2);\r\n *\r\n * uq([1, 2, 3, 4, 5]); // => [3, 4, 5]\r\n */\r\nexport default curry((fn, list) =>\r\n  list.reduce((acc, a) => {\r\n    if (acc.map(fn).indexOf(fn(a)) === -1) {\r\n      return acc.concat(a);\r\n    }\r\n\r\n    return acc;\r\n  }, []));\r\n","/**\r\n * @name assign\r\n * @since v0.1.0\r\n * @category Object\r\n * @sig {k: v} -> {k: v} -> {k: v}\r\n * @description Create a new object from the provided objects in the parameters defaults to Object.assign if able\r\n * @param  {Object} args The object(s) we want to combine\r\n * @return {Object} A new Object\r\n *\r\n * @example\r\n * assign({ a: 1 }); // => { a: 1 }\r\n * assign({ test: 1 }, { thing: 2 }); // => { test: 1, thing: 2 }\r\n * assign({ a: 1, b: 2, c: 3 }, { c: 5, d: 3 }); // => { a: 1, b: 2, c: 5, d: 3 }\r\n * assign({ a: 1 }, { b: 2 }, { c: 5 }, { c: 3 }, { d: 4 }); // => { a: 1, b: 2, c: 3, d: 4 }\r\n */\r\nexport default (...args) =>\r\n  args.reduce((acc, x) =>\r\n    ({\r\n      ...acc,\r\n      ...x\r\n    }), {});\r\n","\r\n/**\r\n * @name capitalize\r\n * @since v2.0.0\r\n * @category String\r\n * @sig String -> String\r\n * @description Capitalizes the first letter of a string\r\n * @param {String} str The string we want to capitalize\r\n * @return {String} The capitalized string\r\n *\r\n * @example\r\n *\r\n * capitalize('test'); // => 'Test'\r\n * capitalize('small brown cow'); // => 'Small brown cow'\r\n */\r\nexport default str => str.charAt(0).toUpperCase() + str.slice(1);\r\n","import isObject from './_internals/isObject';\r\n\r\n/**\r\n * @name clone\r\n * @since v0.1.0\r\n * @category Object\r\n * @sig {*} -> {*}\r\n * @description Shallow clone an object or array\r\n * @param  {Object} x The object that should be cloned\r\n * @return {Object} Returns the shallow clone of the object\r\n * @example\r\n * const obj = clone({things: 1}); // => { things: 1 }\r\n * const arr = clone([1, 2, 3]); // => [1, 2, 3]\r\n */\r\nexport default x => isObject(x) ? { ...x } : x;\r\n","import isNil from './isNil';\r\n\r\n/**\r\n * @name compress\r\n * @since v0.3.0\r\n * @category Object\r\n * @sig Object a -> Object b\r\n * @description Takes an object and compresses it down removing undefined or null values\r\n * @param {Object} obj The Object to compress\r\n * @return {Object} Returns a new object without the unwanted values\r\n *\r\n * @example\r\n * compress({ thing: '', test: 1, other: undefined }); // => { thing: '', test: 1 }\r\n * compress({ thing: '', test: 1, other: null }); // => { thing: '', test: 1 }\r\n */\r\nexport default obj =>\r\n  Object.keys(obj).reduce((acc, k) => {\r\n    if (!isNil(obj[k])) {\r\n      acc[k] = obj[k];\r\n    }\r\n\r\n    return acc;\r\n  }, {});\r\n","\r\n/**\r\n * @name curryN\r\n * @category Function\r\n * @sig Number -> ((a, b) -> c) -> a -> b -> c\r\n * @description Acts like curry but this one expects you to tell it how many arguments to expect\r\n * this allows it to work well with rest parameters and default params.\r\n * @param {Number} n The number of arguments the function is expecting\r\n * @param {Function} f The function we are going to be running with said arguments\r\n * @param {Any} args The arguments to apply to said function curry wont execute until this length matches n\r\n * @return {Any} Returns based on the results of the function passed in\r\n *\r\n * @example\r\n *\r\n * const add = curryN(2, (a, b) => a + b);\r\n *\r\n * add(1)(2); // => 3\r\n * add(1, 2); // => 3\r\n *\r\n * const sum = add(1);\r\n *\r\n * sum(2); // => 3\r\n * sum(4); // => 5\r\n *\r\n * const add2 = curryN(2, (a, b = 1) => a + b);\r\n * const sum1 = add(1);\r\n *\r\n * sum1(4); // => 5\r\n * sum1(undefined); // => 2\r\n */\r\nconst curryN = (n = 0, f, ...args) => {\r\n  if (n <= 0) {\r\n    return f(...args);\r\n  }\r\n\r\n  return (...rest) => curryN(n - rest.length, f, ...args, ...rest);\r\n};\r\n\r\nexport default curryN;\r\n","/**\r\n * @name deepClone\r\n * @since v0.1.0\r\n * @category Function\r\n * @sig {*} -> {*}\r\n * @description Clones the object sent in (Hard Clone)\r\n * @param  {Any} x The value we want to get cloned\r\n * @return {Any} The newly cloned value\r\n *\r\n * @example\r\n * const data = { test: 1 }\r\n * const cloned = deepClone(data); // => { test: 1 }\r\n *\r\n * cloned.test = 2;\r\n *\r\n * console.log(data); // => { test: 1 }\r\n * console.log(cloned); // => { test: 2 }\r\n */\r\nexport default x => JSON.parse(JSON.stringify(x));\r\n","import type from './type';\r\n\r\n/**\r\n * @name empty\r\n * @since v0.1.0\r\n * @category Function\r\n * @sig a -> a\r\n * @description Empties out the items of the sent value\r\n * @param  {*} x The item to empty\r\n * @return {*} Returns the empty item\r\n *\r\n * @example\r\n * const obj = empty({ test: 1 }); // => {}\r\n * const arr = empty([1, 2, 3]); // => []\r\n * const str = empty('test'); // => ''\r\n */\r\nexport default x => {\r\n  if (type(x) === 'Array') {\r\n    return [];\r\n  }\r\n\r\n  if (type(x) === 'String') {\r\n    return '';\r\n  }\r\n\r\n  if (type(x) === 'Object') {\r\n    return {};\r\n  }\r\n\r\n  throw new TypeError('Empty requires an emptyable type, like a String or Array');\r\n};\r\n\r\n","/**\r\n * @name entries\r\n * @since v2.0.3\r\n * @category Object\r\n * @sig Object { k: v } -> Array [k, v]\r\n * @description Creates an array of arrays with the key value pairs of an object\r\n * @param {Object} obj The object we want to grab our data from\r\n * @return {Array} An array of arrays with the key value pairs from the object\r\n *\r\n * @example\r\n *\r\n * entries({ a: 1, b: 2, c: 3 }); // => [['a', 1], ['b', 2], ['c', 3]]\r\n */\r\nexport default obj =>\r\n  Object.keys(obj).map(k => [k, obj[k]]);\r\n","/**\r\n * @name first\r\n * @since v0.4.0\r\n * @category Array\r\n * @sig [a] -> a | Undefined\r\n * @description Grabs the first index of a passed array or string\r\n * @param  {Array|String} x The list or string we want to use\r\n * @return {Any} Returns whatever was the first piece of our array\r\n *\r\n * @example\r\n * const arr = first([1, 3]); // => 1\r\n * const str = first('abc'); // => 'a'\r\n */\r\nexport default x => x[0];\r\n","\r\n/**\r\n * @name identity\r\n * @since v2.0.0\r\n * @category Function\r\n * @sig a -> a\r\n * @description A function that returns the value passed to it\r\n * @param {Any} a The value to return\r\n * @return {Any} The value\r\n *\r\n * @example\r\n * identity(10); // => 10\r\n *\r\n * const test = identity(10);\r\n *\r\n * console.log(typeof test.constructor); // => 'function'\r\n * console.log(10.constructor); // => error\r\n *\r\n * filter(identity, [0, 'cool', null, 1]); // => ['cool', 1]\r\n */\r\nexport default a => a;\r\n","import not from './not';\r\n\r\n// To keep checks strict we sadly have to use this\r\n/* eslint-disable no-undefined */\r\n\r\n/**\r\n * @name isEmpty\r\n * @since v0.1.0\r\n * @category Function\r\n * @sig a -> Boolean\r\n * @description Determines if the entered value is empty or not\r\n * @param  {Any} x Value to check against\r\n * @return {Boolean} Returns the boolean after running our check\r\n *\r\n * @example\r\n * const arr = isEmpty([]); // => true\r\n * const obj = isEmpty({}); // => true\r\n * const str = isEmpty(''); // => true\r\n * const num = isEmpty(0); // => true\r\n */\r\nexport default x => not(Boolean(Object.keys(x).length));\r\n","import _equal from './_internals/equal';\r\n\r\n/**\r\n * @name isEqual\r\n * @since v0.1.0\r\n * @category Relation\r\n * @sig a -> b -> Boolean\r\n * @description Takes and compares two items. Capable of handling cyclical data structures\r\n * @param  {Any} a First item to compare\r\n * @param  {Any} b Second item to compare\r\n * @return {Boolean} Returns the boolean after running our comparison check\r\n *\r\n * @example\r\n * const obj = isEqual({}, {}); // => true\r\n * const arr = isEqual([], []); // => true\r\n */\r\nexport default (a, b) => _equal(a, b, [], []);\r\n","/**\r\n * @name juxt\r\n * @since v0.5.0\r\n * @category Function\r\n * @sig (a, b, …, m) → n → ((a, b, …, m) → [n])\r\n * @description Applies the provided function and turns them into a single function you can use on a value\r\n * @param {Function} fns The functions to apply\r\n * @return {Function} The function you can use on your data value\r\n *\r\n * @example\r\n * const getRange = juxt(Math.min, Math.max);\r\n *\r\n * getRange(3, 4, 9, -3); // => [-3, 9]\r\n */\r\nexport default (...fns) =>\r\n  (...x) => fns.map(f => f(...x));\r\n","\r\n/**\r\n * @name last\r\n * @since v0.1.0\r\n * @category Array\r\n * @sig\r\n * [a] -> a | Undefined\r\n * String -> String\r\n * @description Grabs the last index of an array\r\n * @param  {Array|String} x The list or string we want to use\r\n * @return {Any} Returns whatever was the last piece of our array\r\n *\r\n * @example\r\n * const arr = last([1, 3]); // => 3\r\n * const str = last('abc'); // => 'c'\r\n */\r\nexport default x => x[x.length - 1];\r\n","\r\n/**\r\n * @name length\r\n * @since v2.0.0\r\n * @category Array\r\n * @sig Array a -> Number\r\n * @description Obtains the length of the passed array\r\n * @param {Array} a The array to find the length of\r\n * @return {Number} The length of the array\r\n *\r\n * @example\r\n * length([1, 2, 3, 4]); // => 4\r\n * length([]); // => 0\r\n */\r\nexport default a => a.length;\r\n","import nth from './nth';\r\n\r\n/**\r\n * @name max\r\n * @since v1.0.0\r\n * @category Array\r\n * @description\r\n * Goes through an array of values and grabs the last value of the array when it's been sorted\r\n * @param {Array} x The Array to sort and grab from\r\n * @return {Any} Returns the item at the end of an array based on what's passed in\r\n *\r\n * @example\r\n * max([1, 3, 2, 5, 4]); // => 5\r\n * max(['c', 'a', 'b', 'f']); // => 'f'\r\n */\r\nexport default x => nth(-1, x.sort((a, b) => a > b));\r\n","/**\r\n * @name mean\r\n * @since v0.1.0\r\n * @category Array\r\n * @sig [Number] -> Number\r\n * @description Get the mean of a set of numbers\r\n * @param  {Array} x An amount of numbers to get the mean from\r\n * @return {Number} Returns the mean avg of the numbers\r\n *\r\n * @example\r\n * mean([1, 2, 3, 2]); // => 2\r\n * mean([]); // => NaN\r\n * mean(); // => NaN\r\n */\r\nexport default (x = []) => x.reduce((a, v) => a + v, 0) / x.length;\r\n","import nth from './nth';\r\n\r\n/**\r\n * @name min\r\n * @since v1.0.0\r\n * @category Array\r\n * @description\r\n * Goes through an array of values and grabs the first value of the array when it's been sorted\r\n * @param {Array} x The Array to sort and grab from\r\n * @return {Any} Returns the item at the start of an array based on what's passed in\r\n *\r\n * @example\r\n * min([1, 3, 2, 5, 4]); // => 1\r\n * min(['c', 'a', 'b', 'f']); // => 'a'\r\n */\r\nexport default x => nth(0, x.sort((a, b) => a > b));\r\n","\r\nconst valid = (a, b) => !isNaN(a) || (b && !isNaN(b));\r\n\r\n/**\r\n * @name range\r\n * @since v0.1.0\r\n * @category Function\r\n * @sig Number -> Number -> [Number]\r\n * @description Create an array range from start to end\r\n * @param  {Number} from Starting number for the range\r\n * @param  {Number} to   Number to end on for the range\r\n * @return {Array}      Returns an array of numbers consisting of the range\r\n *\r\n * @example\r\n * const test = range(3, 7); // => [3, 4, 5, 6]\r\n * const test = range(3); // => [0, 1, 2];\r\n */\r\nexport default (from, to) => {\r\n  if (!valid(from, to)) {\r\n    throw new TypeError('Both Arguments should be a number type');\r\n  }\r\n\r\n  const result = [];\r\n  let stop = to;\r\n  let start = from;\r\n\r\n  if (!to) {\r\n    start = 0;\r\n    stop = from;\r\n  }\r\n\r\n  while (start < stop) {\r\n    result.push(start);\r\n    start += 1;\r\n  }\r\n\r\n  return result;\r\n};\r\n","\r\n/**\r\n * @name reverse\r\n * @since v2.0.0\r\n * @category Array\r\n * @sig Array a -> Array a\r\n * @description Accepts an array and returns a brand new reversed array\r\n * @param {Array} arr The array to reverse\r\n * @return {Array} A new reversed array\r\n *\r\n * @example\r\n * reverse([1, 2, 3]); // => [3, 2, 1]\r\n * reverse([]); // => []\r\n */\r\nexport default arr => arr.slice().reverse();\r\n","/**\r\n * @name values\r\n * @since v2.0.3\r\n * @category Object\r\n * @sig Object { k: v } -> Array v\r\n * @description Grabs the values from a key value pair object\r\n * @param {Object} obj The object we want to grab our values from\r\n * @return {Array} An array of values from the object\r\n *\r\n * @example\r\n *\r\n * value({ a: 1, b: 2, c: 3 }); // => [1, 2, 3]\r\n */\r\nexport default obj =>\r\n  Object.keys(obj).map(k => obj[k]);\r\n","import trim from './trim';\r\n\r\n/**\r\n * @name words\r\n * @since v2.0.0\r\n * @category String\r\n * @sig String -> Array String\r\n * @description\r\n * Takes a string and breaks the words down into an array\r\n * @param {String} str The string we want to break down\r\n * @return {Array} The words broken down into an array of strings\r\n *\r\n * @example\r\n * words('my brown cow'); // => ['my', 'brown', 'cow']\r\n */\r\nexport default str => trim(str).split(/\\s+/);\r\n"],"names":["curry","f","args","length","rest","a","b","Object","prototype","toString","call","x","fn","not","list","indexOf","def","data","keys","reduce","acc","prop","isNil","flatten","concat","Array","isArray","flatRest","filter","undefined","slice","every","idx","len","h","n","hLen","nLen","i","j","nch","charCodeAt","outer","search","gcd","obj","hasOwnProperty","str","Ctor","constructor","next","iter","done","push","value","equal","match","stackA","stackB","identical","type","nullTypeCheck","allTypes","typeCheck","String","_typeof","valueOf","name","message","vals","p","regexCheck","arrayFromIterator","entries","keysA","idy","key","has","pop","Math","abs","floor","map","o","keyArr","ensureArray","v","pass","fail","pluck","val","isObject","init","t","precision","num","roundedNum","round","Number","some","sort","trim","charAt","toUpperCase","k","curryN","JSON","parse","stringify","TypeError","Boolean","_equal","fns","nth","from","to","isNaN","result","stop","start","arr","reverse","split"],"mappings":"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"}